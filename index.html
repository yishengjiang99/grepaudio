<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>rttt</title>
  <link rel="stylesheet" href="style.css">

  <script src="./simple-console.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
    integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
  <link rel="stylesheet" href="./simple-console.css">

  <script src="https://code.jquery.com/jquery-3.5.1.min.js"
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js"></script>

  <script src='typeahead.bundle.min.js'></script>
</head>

<body>
  <div id="overlay" style="display: block; height:100%">
    <div class="text page-header">
      GrepAwk Audio is a shared DSP-over-webrtc tool.

      <br>
      <p style="font-size:20px;" class="w3-black w3-padding w3-hide-medium w3-hide-small">
        <i>"Wake up in the AM and compose a beat" -- Dr. Dre</i>
      </p>
      <button type="button" class="btn btn-primary btn-block">start Audio Context. </button>

    </div>
  </div>

  <nav class="navbar navbar-dark bg-dark text-light flex-md-nowrap p-0 shadow">
    <a class="navbar-brand col-sm-3 col-md-2 mr-0" href="#">GrepAwk DSP</a>
    <input id='ytsearch' class="type-ahead form-control form-control-dark w-100" type="text" placeholder="Search Music"
      aria-label="Search">
    <ul class="navbar-nav px-3">
      <li class="nav-item text-nowrap">
        <button class="btn btn-primary" href="#">Broadcast</button>
      </li>
    </ul>
  </nav>

  <div class="container-fluid bg-dark text-white">
    <div class="row">
      <nav class="navbar col-md-3 sidebar">
        <div id=ctrls class="nav flex-column">
        </div>
        <input id=file type=file />;
      </nav>

      <main role="main" class="col-md-8 sp-3 col-lg-8">
        <h4>Mix Sounds</h4>
        <div id='serverlist'></div>
        <div class='d-block p-2' id="eq_update_form">
        </div>
        <div class='canvas_wrapper'>
          <div class="btn-group mr-2">
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="checkbox" id='showfft' type=checkbox checked>fft</input>
              <label class="form-check-label" for="inlineCheckbox1">fft</label>
            </div>
            <div class="form-check form-check-inline">
              <input class="form-check-input" id='showcummulative' type=checkbox>
              <label class="form-check-label" for="inlineCheckbox2">timeseries</label>
            </div>
            <div class="form-check form-check-inline">
              <input class="form-check-input" id='showcummulative' type=checkbox>
              <label class="form-check-label" for="inlineCheckbox3">cumulative fft</label>
            </div>

            <button id='zoomin' type="button" class="btn btn-sm btn-outline-secondary">+</button>
            <button id='zoomout' type="button" class="btn btn-sm btn-outline-secondary">-</button>
          </div>

          <figure class='well'>
            <canvas id='output_freq'></canvas>
            <figcaption class="figure-caption">FFT Bins</figcaption>

          </figure>
          <figure class='well'>
            <span id='rx0'></span>
            <span id='rx1'></span>
            <canvas id='output_timeline'></canvas>
            <figcaption class="figure-caption">PCM 32bit sample</figcaption>

          </figure>
          <figure class='well'>
            <canvas id='band_freq_out'></canvas>
            <figcaption class="figure-caption">FFT Bins</figcaption>

          </figure>
        </div>
      </main>
    </div>
  </div>

  <div id=console></div>

  <div id='rx2log'></div>


  <div id=output_cp class=text-white style='position:fixed; width:20%; top:40vh;right:0;'>
    <ul id=channels></ul>
    <div><button id=obs>Broadcast</button> <button id=listen>Listen</button></div>
    <div>
      <button id="recorder">Start Recording</button>
      <span class='text-white' id='rinfo'></span>
      <span class='text-white' id='rdownload'></span>

    </div>
    <div><audio id='audio2' controls></audio></div>
    <div><audio id='audio1' controls src=''></audio></div>
    <video id=rtc></video>
  </div>

  <script id="result-template" type="text/x-handlebars-template">
            <div class="ProfileCard u-cf">
              <img class="ProfileCard-avatar" src="{{thumbnail}}">
          
              <div class="ProfileCard-details">
                <div class="ProfileCard-realName">{{title}}</div>
                <div class="ProfileCard-screenName">{{channelTitle}}</div>
                <div class="ProfileCard-description">{{description}}</div>
              </div>
            </div>
          </script>

  <script src='polyfills.js'></script>


  <script type='module'>
    var $j = jQuery.noConflict();

import equilizer from "./equalizer.js";
import Mixer from './Mixer.js';
import NoiseGate from './NoiseGate/NoiseGate.js'
import { split_band } from './splitband.js'
import AnalyzerView from "./AnalyzerView.js"
import BandPassFilterNode from './band_pass_lfc/BandPassFilterNode.js'
import BroadcasterClient from './twitch/BroadcastClient.js'
import BoardcastViewerClient from './twitch/BroadcastViewerClient.js'
import { selector, slider, numeric } from "./functions.js";
import https_rtc_client from './dsp_rtc/https_rtc_client.js';
import draw from './GEQ/draw.js`;

let audioCtx, audioTag, eq;


const overlay = document.getElementById("overlay");

overlay.onclick = async function (e) {
  this.removeFromParent;

  audioCtx = new AudioContext();
  await audioCtx.audioWorklet.addModule('../band_pass_lfc/processor.js');

  window.g_audioCtx = audioCtx;

  var audioTag = await Mixer(audioCtx, "ctrls");
  var ytSearch = new Bloodhound({
    datumTokenizer: Bloodhound.tokenizers.obj.whitespace('value'),
    queryTokenizer: Bloodhound.tokenizers.whitespace,
    prefetch: '/samples/yt.json',
    remote: {
      url: '/api/yt/%QUERY',
      wildcard: '%QUERY'
    }
  });

  ytSearch.initialize();
  const template = Handlebars.compile($j("#result-template").html());


  audioTag.add_audio_tag("audio1", 5);
  const audio1 = $("#audio1");
  window.g_audioTag = audioTag;
  var noiseGate = new NoiseGate(audioCtx);
  noiseGate.port.postMessage("ping");
  noiseGate.port.onmessage = (evt) => {
    log(JSON.stringify(evt.data));
  }
  audioTag.outputNode.connect(noiseGate.input);
  var bandpassFilterNode = await new BandPassFilterNode(audioCtx);
  noiseGate.output.connect(bandpassFilterNode);



  var cursor = bandpassFilterNode;

  var compressor = new DynamicsCompressorNode(audioCtx, { threshold: -10, ratio: 20, knee: 10 });

  var group = split_band(audioCtx, [31.25, 62.5, 125, 250, 500, 1000, 2000, 4000, 8000, 16000]);
  bandpassFilterNode.connect(compressor).connect(group.input);

  $("#eq_update_form").appendChild(group.UI_EQ(bandpassFilterNode, compressor));




  cursor = group.output;
  var ctv = AnalyzerView(cursor, { fft: 256 });
  ctv.histogram("output_freq", 700, 300); //, { fft: 256 })
  ctv.timeseries("output_timeline", 128, 700, 300); //, { fft: 256 })

  var recorderProcessor = audioCtx.createScriptProcessor(1024, 2, 2);
  var counter = 0;
  recorderProcessor.onaudioprocess = (e) => {

    // The input buffer is the song we loaded earlier
    var inputBuffer = e.inputBuffer;

    // The output buffer contains the samples that will be modified and played
    var outputBuffer = e.outputBuffer;
    var buffer = [];
    for (var channel = 0; channel < outputBuffer.numberOfChannels; channel++) {
      var inputData = inputBuffer.getChannelData(channel);
      var outputData = outputBuffer.getChannelData(channel);
      if (isRecording) buffer.push(inputData);

      // Loop through the 4096 samples
      for (var sample = 0; sample < inputBuffer.length; sample++) {
        // make output equal to the same as the input
        outputData[sample] = inputData[sample];
      }
    }
    if (!isRecording) return;
    rworker.postMessage({
      command: 'record',
      buffer: buffer
    });
    counter += buffer.length;
  };

  var playbackGain = audioCtx.createGain({ gain: 1 });

  ctv.analyzer.connect(recorderProcessor);

  recorderProcessor.connect(playbackGain);
  playbackGain.connect(audioCtx.destination);

  var isRecording = false;
  var chunks = [];
  const outputdiv = $("#output_cp");

  const playbackGainSlider = slider(outputdiv, { wrap: "inline", prop: playbackGain.gain, min: "0", max: "4", step: "0.05", label: "Local Playback gain" });
  var bv = BoardcastViewerClient({
      onEvent: log,
      mediaObjectReady: function (stream) {
        // audio22.srcObject = stream;
        // audio22.play();
        // //sream = new MediaStream([e.track]);
        var source = audioCtx.createMediaStreamSource(stream);
        audioTag.add_remote_stream(source, 1);
      }
    });



  $("#obs").onclick = function (e) {
    var userId = window.location.search.replace("?", "")
      || prompt("enter display name", (localStorage.getItem("displayName") || ""))
      || ("user_" + Math.floor(Math.random() * 10));

    var peer = audioCtx.createMediaStreamDestination();
    playbackGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
    playbackGainSlider.value = "0.001";
    recorderProcessor.connect(peer);
    localStorage.setItem("displayName", userId)
    BroadcasterClient({
      onEvent: log
    }).broadcastAudio(userId, peer.stream);

  }
  const audio22 = $("video#rtc")
  $("#listen").onclick = function (e) {
    bv.listChannels().then(channels => {
      for (const channel of Object.values(channels)) {
        var a = document.createElement("a");
        a.onclick = function () {
          bv.watchChannel(channel.name);
        }
        a.href = "javascript://"
        a.innerText = "watch"
        var li = document.createElement("li");
        li.append(a);
        li.appendstr(" " + channel.name);
        $("#channels").append(li);
      }
    });
  }

  $("#recorder").onclick = function (e) {
    var t;
    function showCounter() {
      document.getElementById("rinfo").innerHTML = (counter / 1000) + "kb";
      t = setTimeout(showCounter, 1000);
    }
    if (isRecording == false) {
      showCounter();
      isRecording = true;
      e.target.innerText = 'Done'
    } else {
      isRecording = false;
      rworker.postMessage({
        command: "exportWAV",
        type: "audio/wav"
      })
      e.target.innerText = 'record'

      cancelAnimationFrame(t)
    }
  }
  var rworker = new Worker('recorder-worker.js');
  var rconfig = { sample: 2 << 16, channels: 1 };
  rworker.postMessage({
    command: 'init',
    config: {
      sampleRate: audioCtx.sampleRate,
      numChannels: 2,
    }
  });

  rworker.onmessage = (e) => {
    if (e.data.audioUrl) {
      log(" got url " + e.data.audioUrl)
      $("#audio2").src = e.data.audioUrl;
      $("#audio2").controls = true;
      isRecording = false;
      $("#rdownload").innerHTML = `<a href='${e.data.audioUrl}'>Download</a>`;
    }
    console.log(e);
  };

  $("#overlay").style.zIndex = -99;

  var ytSearch = new Bloodhound({
    datumTokenizer: Bloodhound.tokenizers.obj.whitespace('value'),
    queryTokenizer: Bloodhound.tokenizers.whitespace,
    prefetch: '/samples/yt.json',
    remote: {
      url: '/api/yt/%QUERY',
      wildcard: '%QUERY'
    }
  });

ytSearch.initialize();
$j('#ytsearch').typeahead(
  { hint: true, highlight: true,minLength: 1},
  { 
    name: 'ytmusic', 
    templates: {
      empty: ['<div class="empty-message">','not found','</div>'].join('\n'),
      suggestion: template
    },
    displayKey: 'title',source: ytSearch
  })
  .on('typeahead:selected', function(evt, item) {
    audio1.src = '/api/'+item.vid+'.mp3';
    audioTag.add_remote_stream( audioCtx.createMediaElementSource(audio1), 0, "loading "+item.title);
    return item;
  });

  window.vfs = [group, audioTag, noiseGate, bandpassFilterNode, audioCtx, group];

  window.index_stdin = function (str) {
    const cmd = str.split(" ")[0];
    const arg1 = str.split(" ")[1] || "";
    const arg2 = str.split(" ")[2] || "";
    switch (cmd) {
      case 'debug':
        switch (arg1) {
          case 'group': group.aggregate_fr(); break;
          default: break;
        }
      case "ls":
        return JSON.stringify(window.g_audioTag)
        break;
      case 'fullscreen':
      case 'terminal':
      case 'term':
        $("#app1").style.display = 'none';
        con.element.style.height = '100vh';
        return true;
      case "ls":
        var str = window.vfs.map(obj => objs.toString()).forEach(str => log(str));
        log(str);
        return true;
      case 'v':
      case 'video':

        g_audioTag.loadURLTo("/api" + arg1 + ".mp3", 1);
      default: return false;
    }
  }

  if (location.hash) {
    window.index_stdin(location.hash)
  }

  con.element.style.zIndex = 99;
  con.element.addEventListener("click", function () { this.querySelector("input").focus() });
  window.onkeydown = function (evt) {
    if (evt.code == "Enter") {
      con.element.querySelector("input").focus();
    }
  }


  var blobbb = window.URL || window.webkitURL;

  document.getElementById('file').addEventListener('change', function (event) {
    var file = this.files[0];
    var fileURL = blobbb.createObjectURL(file);
    $("#audio2").src = fileURL;
    $("#audio2").autoplay = true;
  });
}



  </script>

</body>

</html>
