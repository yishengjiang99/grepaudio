<html>
<style>
  body {
    background-color: gray;
    color: white;
  }

  .wrapper {
    width: 50vw;
    height: 500px;
  }



  #console{
    position:fixed;
    bottom:0;
    background-color:black;
    color:white;
    opacity: 0.2;
    height:20vh;
  }
</style>
  <script src="./simple-console.js"></script>
    <script src="https://unpkg.com/konva@5.0.3/konva.min.js"></script>

<body>
  <audio controls src='/Dr Dre- Still Dre instrumental-JVISRjhXzzM.webm'></audio>
  <div id=status></div>


<div id='chart' class='wrapper' style="position: relative;">
 <canvas id="layer1" width="100" height="100" 
   style="position: absolute; left: 0; top: 0; z-index: 1;"></canvas>
 <canvas id="layer2" width="100" height="100" 
   style="position: absolute; left: 0; top: 0; z-index: 0;"></canvas>
</div>
  <div id=console>aaa</div>
  <script src='polyfills.js'></script>
  <script type=module>

    const audio1 = document.querySelector('audio');
const ctx = new AudioContext();
import {HZ_LIST} from './constants.js';
import Effects from './effects.js'
import AnalyzerView from './AnalyzerView.js'

var node = ctx.createMediaElementSource(audio1);




var piano = new Effects(ctx);

var c = piano;

var filters = [{ "frequency": 32, "Q": 1, "gain": 1, "type": "highshelf" },
{ "label": "64", "frequency": 64, "Q": 1, "gain": 1, "type": "peaking" },
{ "label": "125", "frequency": 125, "Q": 1, "gain": 1, "type": "peaking" },
{ "label": "250", "frequency": 250, "Q": 1, "gain": 1, "type": "peaking" },
{ "label": "500", "frequency": 500, "Q": 1, "gain": 1, "type": "peaking" },
{ "label": "1000", "frequency": 1000, "Q": 1, "gain": 1, "type": "peaking" },
{ "label": "2k", "frequency": 2000, "Q": 1, "gain": 1, "type": "peaking" },
{ "label": "4k", "frequency": 4000, "Q": 1, "gain": 1, "type": "peaking" },
{ "label": "8k", "frequency": 8000, "Q": 1, "gain": 1, "type": "peaking" },
{ "label": "16k", "frequency": 16000, "gain": 1, "type": "lowshelf" }]
  .map(config => {
    const handler = {
      set(target, key, value) {
        target[key] = value;
      },
    };
    var b = new BiquadFilterNode(ctx, { frequency: config.frequency, Q: config.q, type: config.type, gain: 1 });

    new Proxy(b.gain, handler);
    c.connect(b)
    c = b;
    return b;
  });

var magResponse = new Float32Array(width);
var phaseResponse = new Float32Array(width);
var aggregate = new Float32Array(width).fill(0);

var knobRadius = 5;
var centerFreqKnobs = Array(filters.length).fill(null)




var canvas = document.querySelectorAll('#chart canvas')[0];
var histogram = document.querySelectorAll('#chart canvas')[1];
var vtx = canvas.getContext('2d');

canvas.setAttribute('width', canvas.parentElement.clientWidth);
canvas.setAttribute('height', canvas.parentElement.clientHeight);

var width = canvas.parentElement.clientWidth;
var height = canvas.parentElement.clientHeight;

var filterIndexInFocus = -1;

const noctaves = 11;
const nyquist = ctx.sampleRate / 2;

const freqs = calcNyquists(width);
function xToFreq(x) {
  return freqs[x];
}
  const av = new AnalyzerView(c);
  av.histogram('layer2',  width, height);
var a = ctx.createAnalyser();
c.connect(a).connect(ctx.destination);




var dbScale = 12;
var pixelsPerDb = (0.5 * height) / dbScale;

// log(freqs);
canvas.addEventListener('wheel', function (event) {
  event.preventDefault();

  if (event.deltaY < 0) {
    console.log('scrolling up');
    if (canvas_zoomscale < 3) canvas_zoomscale += 0.05;
    document.getElementById('status').textContent = 'scrolling up';
    drawScalesAndFrequencyResponses();

  }
  else if (event.deltaY > 0) {
    if (canvas_zoomscale > 0.5) canvas_zoomscale -= 0.05;
    drawScalesAndFrequencyResponses();
    console.log('scrolling down');
    document.getElementById('status').textContent = 'scrolling down';
  }
});

function YToDb(y){
  var db = (0.5 * height -   y/canvas_zoomscale) / pixelsPerDb;
  return db;
}
  function dbToY(db) {
    var y = ((0.5 * height) - pixelsPerDb * db) * canvas_zoomscale;
    return y;
  }

var dirty = true;
var canvas_zoomscale = 1;
drawScalesAndFrequencyResponses();

function drawScalesAndFrequencyResponses() {
  centerFreqKnobs = Array(filters.length).fill(null);
  vtx.clearRect(0, 0, width, height);
  vtx.fillStyle = 'rgba(255,255,255,0.01)';
  vtx.fillRect(0, 0, width, height);
  // Draw frequency scale.
  var curveColor = "rgb(192,192,192)";
  var playheadColor = "rgb(80, 100, 80)";
  var gridColor = "rgb(100,100,100)";
  // Draw 0dB line.
  vtx.beginPath();
  vtx.moveTo(0, 0.5 * height);
  vtx.lineTo(width, 0.5 * height);
  vtx.stroke();
  for (var octave = 0; octave <= noctaves; octave++) {
    var x = octave * width / noctaves;
    vtx.strokeStyle = gridColor;
    vtx.moveTo(x, 30);
    vtx.lineTo(x, height);
    vtx.stroke();
    var f = ctx.sampleRate / 2 * Math.pow(2.0, octave - noctaves);
    vtx.textAlign = "center";
    vtx.strokeStyle = curveColor;
    vtx.strokeText(f.toFixed(0) + "Hz", x, 20);
  }
  const canvasContext = vtx;
  for (var db = -dbScale; db < dbScale; db += 5) {
    var y = dbToY(db);
    canvasContext.strokeStyle = curveColor;
    canvasContext.strokeText(db.toFixed(0) + "dB", width - 40, y);

    canvasContext.strokeStyle = gridColor;
    canvasContext.beginPath();
    canvasContext.moveTo(0, y);
    canvasContext.lineTo(width, y);
    canvasContext.stroke();
  }

  var cc = ['blue', 'red', 'green'];


  var magResponse = new Float32Array(width);
  var phaseResponse = new Float32Array(width);
  var aggregate = new Float32Array(width).fill(0);
  var knobRadius = 5;

  vtx.strokeStyle = 'white'
  vtx.strokeWidth = '1px';
  
  for (let i in filters) {
    const filter = filters[i]
    vtx.beginPath();
    vtx.moveTo(0, dbToY(0));

    if (dirty == true) {
      filter.getFrequencyResponse(freqs, magResponse, phaseResponse);
      for (var k = 0; k < width; ++k) {
        db = 20.0 * Math.log(magResponse[k]) / Math.LN10;
        var phaseDeg = 180 / Math.PI * phaseResponse[k];
        var realdb = db;//db * Math.cos(phaseDeg);
        aggregate[k] += realdb;
        let y = dbToY(realdb)
        vtx.lineTo(k, dbToY(realdb));
        if (freqs[k] >= filter.frequency.value && centerFreqKnobs[i] == null) {
          centerFreqKnobs[i] = [k, y];
        }
      }
    }


    vtx.stroke();
    vtx.closePath();
    console.log(i, 'vs', filterIndexInFocus)
    if (i == filterIndexInFocus) {
      vtx.fillStyle = `rgb(133,${i * 100},${i % 2 * 31},0.8)`;
      vtx.fill();
    }

  }

  for (let i = 0; i < centerFreqKnobs.length; i++) {
    vtx.fillStyle = 'red';
    vtx.beginPath();
    vtx.arc(
      centerFreqKnobs[i][0] - knobRadius,
      centerFreqKnobs[i][1] + knobRadius,
      knobRadius, 0, Math.PI * 2, false);
    vtx.closePath();
    vtx.fill();
  }
  vtx.beginPath();

  for (var k = 0; k < width; ++k) {
    var y = 20 * Math.log(aggregate[k]) / Math.LN10;
    vtx.lineTo(k, dbToY(aggregate[k]));
  }
  vtx.closePath();
  vtx.stroke();
  dirty = false;
  //requestAnimationFrame(drawScalesAndFrequencyResponses);
}


var filterIndexInFocus = -1;
var lastClick;
canvas.ondblclick = function (e) {
  log(" time sinze last click " + (ctx.currentTime - lastClick));
  if (filterIndexInFocus > -1) {
    let cval = filters[filterIndexInFocus].gain.value;
    filters[filterIndexInFocus].gain.setValueAtTime(YToDb(e.offsetY), ctx.currentTime);

    dirty = true;
    drawScalesAndFrequencyResponses();

  }
}

canvas.onmousedown = function (e) {
  focusClosest(e);
}

canvas.onmouseup = function(e){

}

canvas.ondragstart = function(e){
  focusClosest(e);

}
canvas.parentElement.onmousemove = function(e){
  if(e.button > 0){
    filters[filterIndexInFocus].gain.setValueAtTime(YToDb(e.offsetY), ctx.currentTime);
  }

}
function focusClosest(e){
  const mousex = e.offsetX;
  var lastFocus = filterIndexInFocus;
  var closest = width;
  lastClick = ctx.currentTime;

  for (let i in centerFreqKnobs) {
    if (Math.abs(centerFreqKnobs[i][0] - mousex) < closest) {
      filterIndexInFocus = i;
      closest = Math.abs(centerFreqKnobs[i][0] - mousex);
    }
  }
  if (filterIndexInFocus !== lastFocus) {
    dirty = true;
    drawScalesAndFrequencyResponses();
  }
}

function calcNyquists(width) {
  var freq = new Float32Array(width);
  for (var k = 0; k < width; ++k) {
    var f = k / width;
    f = Math.pow(2.0, noctaves * (f - 1.0));
    freq[k] = f * nyquist;
  }
  window.allfreqs = freq;
  return freq;
}

// 2^(noctaves*(x/width -1))

// freq  =   2^(noctaves*(x/width -1))
// log2(freq) = noctaves*(x/width-1);
// width* (log2(freq)/noctaves + 1) = x

var logentries = Array(30).fill("");
var cursor = 0;

  </script>
</body>

</html>